package pages

import (
	"fmt"
	"time"

	"forge.internal/nemo/avalanche/src/sentinel/templates/layouts"
)

// TailscalePeerInfo represents a Tailscale peer for display.
type TailscalePeerInfo struct {
	ID             string
	HostName       string
	DNSName        string
	TailscaleIPs   []string
	Online         bool
	LastSeen       time.Time
	OS             string
	ExitNode       bool
	ExitNodeOption bool
	SubnetRouter   bool
	Subnets        []string
	IsSelf         bool
}

// TailscalePageParams contains parameters for the Tailscale page.
type TailscalePageParams struct {
	Username       string
	Role           string
	Available      bool
	BackendState   string
	Self           TailscalePeerInfo
	Peers          []TailscalePeerInfo
	MagicDNSSuffix string
	Error          string
}

// TailscalePage renders the Tailscale peers page.
templ TailscalePage(params TailscalePageParams) {
	@layouts.Authenticated(layouts.AuthenticatedParams{
		Title:       "Tailscale",
		Description: "Tailscale mesh network status",
		Username:    params.Username,
		Role:        params.Role,
		ActiveNav:   "tailscale",
	}) {
		<div class="space-y-6">
			<!-- Page header -->
			<div class="border-b border-gray-200 dark:border-gray-700 pb-5">
				<div class="flex items-center justify-between">
					<div>
						<h1 class="text-2xl font-bold text-gray-900 dark:text-white">Tailscale</h1>
						<p class="mt-2 text-sm text-gray-500 dark:text-gray-400">
							Mesh network peers and status
						</p>
					</div>
					@tailscaleStatusBadge(params.BackendState)
				</div>
			</div>
			if !params.Available {
				<!-- Unavailable state -->
				<div class="rounded-lg bg-gray-50 dark:bg-gray-800 border border-gray-200 dark:border-gray-700 p-8 text-center">
					<svg class="mx-auto h-12 w-12 text-gray-400" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
						<path stroke-linecap="round" stroke-linejoin="round" d="M12 9v3.75m-9.303 3.376c-.866 1.5.217 3.374 1.948 3.374h14.71c1.73 0 2.813-1.874 1.948-3.374L13.949 3.378c-.866-1.5-3.032-1.5-3.898 0L2.697 16.126zM12 15.75h.007v.008H12v-.008z"/>
					</svg>
					<h3 class="mt-4 text-lg font-medium text-gray-900 dark:text-white">Tailscale Unavailable</h3>
					if params.Error != "" {
						<p class="mt-2 text-sm text-gray-500 dark:text-gray-400">{ params.Error }</p>
					} else {
						<p class="mt-2 text-sm text-gray-500 dark:text-gray-400">
							Tailscale daemon is not running or not installed on this system.
						</p>
					}
				</div>
			} else {
				<!-- Self info -->
				<div class="rounded-lg bg-white dark:bg-gray-800 shadow border border-gray-200 dark:border-gray-700 overflow-hidden">
					<div class="px-4 py-5 sm:p-6">
						<h3 class="text-base font-semibold text-gray-900 dark:text-white mb-4">This Device</h3>
						<div class="flex items-start justify-between">
							<div>
								<div class="flex items-center space-x-2">
									<span class="text-lg font-medium text-gray-900 dark:text-white">{ params.Self.HostName }</span>
									<span class="inline-flex items-center rounded-full bg-blue-100 dark:bg-blue-900/50 px-2 py-0.5 text-xs font-medium text-blue-800 dark:text-blue-300">Self</span>
								</div>
								if len(params.Self.TailscaleIPs) > 0 {
									<div class="mt-1 space-y-1">
										for _, ip := range params.Self.TailscaleIPs {
											<span class="block text-sm font-mono text-gray-500 dark:text-gray-400">{ ip }</span>
										}
									</div>
								}
								if params.MagicDNSSuffix != "" {
									<p class="mt-2 text-sm text-gray-500 dark:text-gray-400">
										<span class="font-mono">{ params.Self.HostName }.{ params.MagicDNSSuffix }</span>
									</p>
								}
							</div>
							<div class="flex flex-wrap gap-2">
								if params.Self.ExitNode {
									<span class="inline-flex items-center rounded-md bg-purple-50 dark:bg-purple-900/50 px-2 py-1 text-xs font-medium text-purple-700 dark:text-purple-300">Exit Node (Active)</span>
								} else if params.Self.ExitNodeOption {
									<span class="inline-flex items-center rounded-md bg-gray-100 dark:bg-gray-700 px-2 py-1 text-xs font-medium text-gray-600 dark:text-gray-300">Exit Node</span>
								}
								if params.Self.SubnetRouter {
									<span class="inline-flex items-center rounded-md bg-orange-50 dark:bg-orange-900/50 px-2 py-1 text-xs font-medium text-orange-700 dark:text-orange-300">Subnet Router</span>
								}
							</div>
						</div>
						if params.Self.SubnetRouter && len(params.Self.Subnets) > 0 {
							<div class="mt-3 pt-3 border-t border-gray-200 dark:border-gray-700">
								<span class="text-xs font-medium text-gray-500 dark:text-gray-400">Advertised Subnets:</span>
								<div class="mt-1 flex flex-wrap gap-2">
									for _, subnet := range params.Self.Subnets {
										<span class="inline-flex items-center rounded bg-gray-100 dark:bg-gray-700 px-2 py-0.5 text-xs font-mono text-gray-700 dark:text-gray-300">{ subnet }</span>
									}
								</div>
							</div>
						}
					</div>
				</div>
				<!-- Peers -->
				<div>
					<h2 class="text-lg font-medium text-gray-900 dark:text-white mb-4">
						Peers
						<span class="ml-2 text-sm font-normal text-gray-500 dark:text-gray-400">({ fmt.Sprintf("%d", len(params.Peers)) })</span>
					</h2>
					<div
						class="grid grid-cols-1 gap-4 sm:grid-cols-2 lg:grid-cols-3"
						hx-get="/api/tailscale/peers"
						hx-trigger="every 30s"
						hx-swap="innerHTML"
					>
						@TailscalePeersPartial(params.Peers)
					</div>
				</div>
			}
		</div>
	}
}

// TailscalePeersPartial renders the peer cards for htmx updates.
templ TailscalePeersPartial(peers []TailscalePeerInfo) {
	if len(peers) == 0 {
		<div class="col-span-full text-center py-8 text-gray-500 dark:text-gray-400">
			No peers connected
		</div>
	} else {
		for _, peer := range peers {
			@tailscalePeerCard(peer)
		}
	}
}

// tailscalePeerCard renders a single peer card.
templ tailscalePeerCard(peer TailscalePeerInfo) {
	<div class="rounded-lg bg-white dark:bg-gray-800 shadow border border-gray-200 dark:border-gray-700 overflow-hidden">
		<div class="p-4">
			<div class="flex items-start justify-between">
				<div class="flex-1 min-w-0">
					<div class="flex items-center space-x-2">
						@tailscaleOnlineIndicator(peer.Online)
						<h3 class="text-sm font-medium text-gray-900 dark:text-white truncate">{ peer.HostName }</h3>
					</div>
					if len(peer.TailscaleIPs) > 0 {
						<p class="mt-1 text-xs font-mono text-gray-500 dark:text-gray-400">{ peer.TailscaleIPs[0] }</p>
					}
				</div>
				<span class={ "inline-flex items-center rounded-md px-2 py-1 text-xs font-medium " + osColorClass(peer.OS) }>
					{ formatOS(peer.OS) }
				</span>
			</div>
			<div class="mt-3 flex flex-wrap gap-2">
				if peer.ExitNode {
					<span class="inline-flex items-center rounded-full bg-purple-100 dark:bg-purple-900/50 px-2 py-0.5 text-xs font-medium text-purple-700 dark:text-purple-300">
						<svg class="mr-1 h-3 w-3" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
							<path stroke-linecap="round" stroke-linejoin="round" d="M15.75 9V5.25A2.25 2.25 0 0013.5 3h-6a2.25 2.25 0 00-2.25 2.25v13.5A2.25 2.25 0 007.5 21h6a2.25 2.25 0 002.25-2.25V15m3 0l3-3m0 0l-3-3m3 3H9"/>
						</svg>
						Exit Node
					</span>
				} else if peer.ExitNodeOption {
					<span class="inline-flex items-center rounded-full bg-gray-100 dark:bg-gray-700 px-2 py-0.5 text-xs font-medium text-gray-600 dark:text-gray-400">
						Exit Node Available
					</span>
				}
				if peer.SubnetRouter {
					<span class="inline-flex items-center rounded-full bg-orange-100 dark:bg-orange-900/50 px-2 py-0.5 text-xs font-medium text-orange-700 dark:text-orange-300">
						<svg class="mr-1 h-3 w-3" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
							<path stroke-linecap="round" stroke-linejoin="round" d="M8.288 15.038a5.25 5.25 0 017.424 0M5.106 11.856c3.807-3.808 9.98-3.808 13.788 0M1.924 8.674c5.565-5.565 14.587-5.565 20.152 0M12.53 18.22l-.53.53-.53-.53a.75.75 0 011.06 0z"/>
						</svg>
						Subnet Router
					</span>
				}
			</div>
			if !peer.Online && !peer.LastSeen.IsZero() {
				<div class="mt-2 text-xs text-gray-400 dark:text-gray-500">
					Last seen { formatLastSeen(peer.LastSeen) }
				</div>
			}
			if peer.SubnetRouter && len(peer.Subnets) > 0 {
				<div class="mt-2 pt-2 border-t border-gray-100 dark:border-gray-700">
					<div class="flex flex-wrap gap-1">
						for _, subnet := range peer.Subnets {
							<span class="inline-flex items-center rounded bg-gray-100 dark:bg-gray-700 px-1.5 py-0.5 text-xs font-mono text-gray-600 dark:text-gray-400">{ subnet }</span>
						}
					</div>
				</div>
			}
		</div>
	</div>
}

// tailscaleOnlineIndicator renders an online/offline indicator.
// Colors chosen to be distinguishable with deuteranopia.
templ tailscaleOnlineIndicator(online bool) {
	if online {
		<span class="h-2 w-2 rounded-full bg-blue-500" title="Online"></span>
	} else {
		<span class="h-2 w-2 rounded-full bg-gray-400" title="Offline"></span>
	}
}

// tailscaleStatusBadge renders the backend state badge.
templ tailscaleStatusBadge(state string) {
	switch state {
		case "Running":
			<span class="inline-flex items-center rounded-full bg-blue-100 dark:bg-blue-900/50 px-3 py-1 text-sm font-medium text-blue-800 dark:text-blue-300">
				<span class="mr-2 h-2 w-2 rounded-full bg-blue-500"></span>
				Connected
			</span>
		case "NeedsLogin":
			<span class="inline-flex items-center rounded-full bg-orange-100 dark:bg-orange-900/50 px-3 py-1 text-sm font-medium text-orange-800 dark:text-orange-300">
				<span class="mr-2 h-2 w-2 rounded-full bg-orange-500"></span>
				Needs Login
			</span>
		case "Stopped":
			<span class="inline-flex items-center rounded-full bg-gray-100 dark:bg-gray-700 px-3 py-1 text-sm font-medium text-gray-800 dark:text-gray-300">
				<span class="mr-2 h-2 w-2 rounded-full bg-gray-500"></span>
				Stopped
			</span>
		default:
			<span class="inline-flex items-center rounded-full bg-red-100 dark:bg-red-900/50 px-3 py-1 text-sm font-medium text-red-800 dark:text-red-300">
				<span class="mr-2 h-2 w-2 rounded-full bg-red-500"></span>
				{ state }
			</span>
	}
}

// formatOS returns a display-friendly OS name.
func formatOS(os string) string {
	switch os {
	case "linux":
		return "Linux"
	case "windows":
		return "Windows"
	case "macOS", "darwin":
		return "macOS"
	case "iOS":
		return "iOS"
	case "android":
		return "Android"
	case "freebsd":
		return "FreeBSD"
	default:
		if os == "" {
			return "Unknown"
		}
		return os
	}
}

// osColorClass returns CSS classes for OS badge colors.
func osColorClass(os string) string {
	switch os {
	case "linux":
		return "bg-orange-50 dark:bg-orange-900/50 text-orange-700 dark:text-orange-300"
	case "windows":
		return "bg-blue-50 dark:bg-blue-900/50 text-blue-700 dark:text-blue-300"
	case "macOS", "darwin", "iOS":
		return "bg-gray-100 dark:bg-gray-700 text-gray-700 dark:text-gray-300"
	case "android":
		return "bg-emerald-50 dark:bg-emerald-900/50 text-emerald-700 dark:text-emerald-300"
	default:
		return "bg-gray-100 dark:bg-gray-700 text-gray-700 dark:text-gray-300"
	}
}

// formatLastSeen formats a time as a relative string.
func formatLastSeen(t time.Time) string {
	d := time.Since(t)

	if d < time.Minute {
		return "just now"
	}
	if d < time.Hour {
		mins := int(d.Minutes())
		if mins == 1 {
			return "1 minute ago"
		}
		return fmt.Sprintf("%d minutes ago", mins)
	}
	if d < 24*time.Hour {
		hours := int(d.Hours())
		if hours == 1 {
			return "1 hour ago"
		}
		return fmt.Sprintf("%d hours ago", hours)
	}

	days := int(d.Hours() / 24)
	if days == 1 {
		return "1 day ago"
	}
	if days < 30 {
		return fmt.Sprintf("%d days ago", days)
	}

	return t.Format("Jan 2, 2006")
}
